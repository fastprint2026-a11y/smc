<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Trading Analyzer - 40+ Chart Patterns & Elliott Wave</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #0f3460;
            --success: #00ff88;
            --danger: #ff4757;
            --warning: #ffa502;
            --info: #3742fa;
            --text: #ffffff;
            --text-muted: #a4b0be;
            --border: #2f3542;
            --bg-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            --card-bg: rgba(26, 26, 46, 0.9);
            --glass: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --glow: 0 0 20px rgba(0, 255, 136, 0.3);
            --elliott-color: #ff6b6b;
            --pattern-color: #4ecdc4;
            --smc-color: #ffe66d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-gradient);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--card-bg);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, var(--success), var(--info));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .controls-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: var(--card-bg);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
        }

        .control-group h3 {
            color: var(--success);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text);
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--success);
            box-shadow: var(--glow);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            transition: all 0.3s ease;
            margin: 5px;
            font-size: 14px;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--success), #00d2ff);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-danger {
            background: linear-gradient(45deg, var(--danger), #ff3838);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, var(--warning), #ff9500);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, var(--info), #5352ed);
            color: white;
        }

        .status-bar {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-muted);
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: var(--success);
        }

        .status-dot.error {
            background: var(--danger);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-top: 20px;
        }

        .signals-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .signal-card {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .signal-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--success), var(--info));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .signal-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            border-color: var(--success);
        }

        .signal-card:hover::before {
            opacity: 1;
        }

        .signal-card.long {
            border-left: 4px solid var(--success);
        }

        .signal-card.short {
            border-left: 4px solid var(--danger);
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .signal-symbol {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text);
        }

        .signal-type {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .signal-type.long {
            background: var(--success);
            color: white;
        }

        .signal-type.short {
            background: var(--danger);
            color: white;
        }

        .pattern-info {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid var(--pattern-color);
        }

        .elliott-info {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 10px;
            border-left: 4px solid var(--elliott-color);
        }

        .smc-info {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 230, 109, 0.1);
            border-radius: 10px;
            border-left: 4px solid var(--smc-color);
        }

        .levels-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .level-item {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .level-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .level-value {
            font-weight: bold;
            font-size: 14px;
        }

        .level-value.entry {
            color: var(--info);
        }

        .level-value.sl {
            color: var(--danger);
        }

        .level-value.tp {
            color: var(--success);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            transition: all 0.3s ease;
        }

        .action-btn.chart {
            background: var(--info);
            color: white;
        }

        .action-btn.tradingview {
            background: #131722;
            color: white;
        }

        .action-btn.binance {
            background: #f0b90b;
            color: black;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }

        .analysis-details {
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-muted);
        }

        .chart-container {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--success);
        }

        .chart-controls {
            display: flex;
            gap: 5px;
        }

        .chart-btn {
            padding: 5px 10px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .chart-btn:hover,
        .chart-btn.active {
            background: var(--success);
            color: white;
        }

        #customChart {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .chart-info {
            font-size: 13px;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid var(--success);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--success);
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .log-container {
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }

        .log-entry.info {
            color: var(--info);
        }

        .log-entry.success {
            color: var(--success);
        }

        .log-entry.error {
            color: var(--danger);
        }

        .log-entry.warning {
            color: var(--warning);
        }

        .pattern-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }

        .pattern-tag {
            padding: 3px 8px;
            background: var(--pattern-color);
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .elliott-tag {
            padding: 3px 8px;
            background: var(--elliott-color);
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .smc-tag {
            padding: 3px 8px;
            background: var(--smc-color);
            color: black;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .confidence-meter {
            margin: 10px 0;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
            transition: width 0.3s ease;
        }

        .confidence-label {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .results-container {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                grid-template-columns: 1fr;
            }
            
            .levels-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: var(--success);
        }

        .notification.error {
            background: var(--danger);
        }

        .notification.info {
            background: var(--info);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 15px;
            padding: 30px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            border: 1px solid var(--border);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            color: var(--success);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: var(--text);
        }

        #fullChart {
            width: 100%;
            height: 600px;
            border-radius: 10px;
        }

        .btc-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .btc-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .btc-indicator.bullish {
            background: var(--success);
        }

        .btc-indicator.bearish {
            background: var(--danger);
        }

        .btc-indicator.neutral {
            background: var(--text-muted);
        }

        .telegram-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .telegram-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .telegram-indicator.connected {
            background: var(--success);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>Professional Trading Analyzer</h1>
            <p>Advanced Chart Pattern Recognition ‚Ä¢ Elliott Wave Analysis ‚Ä¢ Smart Money Concepts</p>
        </div>

        <!-- Controls Panel -->
        <div class="controls-panel">
            <!-- API Configuration -->
            <div class="control-group">
                <h3>üîë API Configuration</h3>
                <div class="form-group">
                    <label>API Type</label>
                    <select id="apiType">
                        <option value="public">Public API (Free)</option>
                        <option value="private">Private API (With Keys)</option>
                    </select>
                </div>
                <div class="form-group" id="apiKeyGroup" style="display: none;">
                    <label>API Key</label>
                    <input type="password" id="apiKey" placeholder="Enter your Binance API Key">
                </div>
                <div class="form-group" id="apiSecretGroup" style="display: none;">
                    <label>API Secret</label>
                    <input type="password" id="apiSecret" placeholder="Enter your Binance API Secret">
                </div>
            </div>

            <!-- Scan Settings -->
            <div class="control-group">
                <h3>‚öôÔ∏è Scan Settings</h3>
                <div class="form-group">
                    <label>Timeframe</label>
                    <select id="timeframe">
                        <option value="5m">5 Minutes</option>
                        <option value="15m">15 Minutes</option>
                        <option value="30m">30 Minutes</option>
                        <option value="1h" selected>1 Hour</option>
                        <option value="4h">4 Hours</option>
                        <option value="1d">1 Day</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Number of Coins to Scan</label>
                    <input type="number" id="coinCount" value="40" min="10" max="200">
                </div>
                <div class="form-group">
                    <label>Minimum Volume (USDT)</label>
                    <input type="number" id="minVolume" value="10000000" step="1000000">
                </div>
            </div>

            <!-- Pattern Settings -->
            <div class="control-group">
                <h3>üìä Pattern Settings</h3>
                <div class="form-group">
                    <label>Pattern Sensitivity</label>
                    <select id="patternSensitivity">
                        <option value="strict">Strict (High Accuracy)</option>
                        <option value="moderate" selected>Moderate</option>
                        <option value="loose">Loose (More Signals)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Elliott Wave Validation</label>
                    <select id="elliottValidation">
                        <option value="strict" selected>Strict (Perfect Waves Only)</option>
                        <option value="moderate">Moderate</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Minimum Confidence (%)</label>
                    <input type="number" id="minConfidence" value="75" min="50" max="95">
                </div>
            </div>

            <!-- Telegram Settings -->
            <div class="control-group">
                <h3>üì± Telegram Notifications</h3>
                <div class="form-group">
                    <label>Bot Token</label>
                    <input type="text" id="telegramToken" placeholder="Enter Telegram Bot Token">
                </div>
                <div class="form-group">
                    <label>Chat ID</label>
                    <input type="text" id="telegramChatId" placeholder="Enter Telegram Chat ID">
                </div>
                <div class="telegram-status">
                    <div class="telegram-indicator" id="telegramIndicator"></div>
                    <span id="telegramStatus">Not Connected</span>
                </div>
            </div>
        </div>

        <!-- Control Buttons -->
        <div style="text-align: center; margin-bottom: 20px;">
            <button class="btn btn-primary" id="startScan">üöÄ Start Professional Scan</button>
            <button class="btn btn-danger" id="stopScan">‚èπÔ∏è Stop Scan</button>
            <button class="btn btn-warning" id="testTelegram">üì± Test Telegram</button>
            <button class="btn btn-info" id="exportResults">üíæ Export Results</button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Ready to scan</span>
            </div>
            <div class="btc-status">
                <div class="btc-indicator neutral" id="btcIndicator"></div>
                <span id="btcStatus">BTC: Analyzing...</span>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-value" id="totalSignals">0</div>
                <div class="stat-label">Total Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="longSignals">0</div>
                <div class="stat-label">Long Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="shortSignals">0</div>
                <div class="stat-label">Short Signals</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="patternsFound">0</div>
                <div class="stat-label">Patterns Found</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="elliottWaves">0</div>
                <div class="stat-label">Elliott Waves</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="avgConfidence">0%</div>
                <div class="stat-label">Avg Confidence</div>
            </div>
        </div>

        <!-- Results Container -->
        <div class="results-container">
            <!-- Signals List -->
            <div class="signals-section">
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Analyzing markets with professional algorithms...</p>
                </div>
                <div class="signals-list" id="signalsList"></div>
            </div>

            <!-- Chart Container -->
            <div class="chart-container">
                <div class="chart-header">
                    <div class="chart-title">Custom Chart Analysis</div>
                    <div class="chart-controls">
                        <button class="chart-btn" id="fullscreenChart">‚õ∂</button>
                        <button class="chart-btn" id="resetChart">‚Üª</button>
                    </div>
                </div>
                <div id="customChart"></div>
                <div class="chart-info" id="chartInfo">
                    Select a signal to view detailed chart analysis with patterns, Elliott waves, and SMC levels.
                </div>
            </div>
        </div>

        <!-- Log Container -->
        <div class="log-container">
            <div id="logContainer"></div>
        </div>
    </div>

    <!-- Chart Modal -->
    <div class="modal" id="chartModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">Chart Analysis</div>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            <div id="fullChart"></div>
            <div class="chart-info" id="modalChartInfo"></div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notificationContainer"></div>

    <script>
        // Global Variables
        let isScanning = false;
        let scanInterval = null;
        let currentSignals = [];
        let btcTrend = 'neutral';
        let customChart = null;
        let fullChart = null;

        // Chart Patterns Database (40+ patterns)
        const CHART_PATTERNS = {
            // Reversal Patterns
            'head_and_shoulders': { name: 'Head and Shoulders', type: 'reversal', reliability: 85 },
            'inverse_head_and_shoulders': { name: 'Inverse Head and Shoulders', type: 'reversal', reliability: 85 },
            'double_top': { name: 'Double Top', type: 'reversal', reliability: 80 },
            'double_bottom': { name: 'Double Bottom', type: 'reversal', reliability: 80 },
            'triple_top': { name: 'Triple Top', type: 'reversal', reliability: 75 },
            'triple_bottom': { name: 'Triple Bottom', type: 'reversal', reliability: 75 },
            'rounding_top': { name: 'Rounding Top', type: 'reversal', reliability: 70 },
            'rounding_bottom': { name: 'Rounding Bottom', type: 'reversal', reliability: 70 },
            'diamond_top': { name: 'Diamond Top', type: 'reversal', reliability: 75 },
            'diamond_bottom': { name: 'Diamond Bottom', type: 'reversal', reliability: 75 },
            'broadening_top': { name: 'Broadening Top', type: 'reversal', reliability: 65 },
            'broadening_bottom': { name: 'Broadening Bottom', type: 'reversal', reliability: 65 },
            'island_reversal': { name: 'Island Reversal', type: 'reversal', reliability: 80 },
            'key_reversal': { name: 'Key Reversal', type: 'reversal', reliability: 70 },
            'hook_reversal': { name: 'Hook Reversal', type: 'reversal', reliability: 65 },
            
            // Continuation Patterns
            'ascending_triangle': { name: 'Ascending Triangle', type: 'continuation', reliability: 75 },
            'descending_triangle': { name: 'Descending Triangle', type: 'continuation', reliability: 75 },
            'symmetrical_triangle': { name: 'Symmetrical Triangle', type: 'continuation', reliability: 70 },
            'bull_flag': { name: 'Bull Flag', type: 'continuation', reliability: 80 },
            'bear_flag': { name: 'Bear Flag', type: 'continuation', reliability: 80 },
            'bull_pennant': { name: 'Bull Pennant', type: 'continuation', reliability: 75 },
            'bear_pennant': { name: 'Bear Pennant', type: 'continuation', reliability: 75 },
            'rectangle': { name: 'Rectangle', type: 'continuation', reliability: 65 },
            'rising_wedge': { name: 'Rising Wedge', type: 'continuation', reliability: 70 },
            'falling_wedge': { name: 'Falling Wedge', type: 'continuation', reliability: 70 },
            'cup_and_handle': { name: 'Cup and Handle', type: 'continuation', reliability: 75 },
            'inverse_cup_and_handle': { name: 'Inverse Cup and Handle', type: 'continuation', reliability: 75 },
            'measured_move': { name: 'Measured Move', type: 'continuation', reliability: 70 },
            'gap_continuation': { name: 'Gap Continuation', type: 'continuation', reliability: 65 },
            
            // Complex Patterns
            'elliott_impulse': { name: 'Elliott Impulse Wave', type: 'complex', reliability: 85 },
            'elliott_corrective': { name: 'Elliott Corrective Wave', type: 'complex', reliability: 80 },
            'harmonic_gartley': { name: 'Harmonic Gartley', type: 'complex', reliability: 80 },
            'harmonic_butterfly': { name: 'Harmonic Butterfly', type: 'complex', reliability: 75 },
            'harmonic_bat': { name: 'Harmonic Bat', type: 'complex', reliability: 75 },
            'harmonic_crab': { name: 'Harmonic Crab', type: 'complex', reliability: 70 },
            'wolfe_wave': { name: 'Wolfe Wave', type: 'complex', reliability: 75 },
            'three_drives': { name: 'Three Drives Pattern', type: 'complex', reliability: 70 },
            'abcd_pattern': { name: 'ABCD Pattern', type: 'complex', reliability: 70 },
            'cypher_pattern': { name: 'Cypher Pattern', type: 'complex', reliability: 75 },
            
            // Candlestick Patterns
            'doji': { name: 'Doji', type: 'candlestick', reliability: 60 },
            'hammer': { name: 'Hammer', type: 'candlestick', reliability: 70 },
            'shooting_star': { name: 'Shooting Star', type: 'candlestick', reliability: 70 },
            'engulfing_bullish': { name: 'Bullish Engulfing', type: 'candlestick', reliability: 75 },
            'engulfing_bearish': { name: 'Bearish Engulfing', type: 'candlestick', reliability: 75 },
            'morning_star': { name: 'Morning Star', type: 'candlestick', reliability: 80 },
            'evening_star': { name: 'Evening Star', type: 'candlestick', reliability: 80 },
            'three_white_soldiers': { name: 'Three White Soldiers', type: 'candlestick', reliability: 75 },
            'three_black_crows': { name: 'Three Black Crows', type: 'candlestick', reliability: 75 },
            'piercing_pattern': { name: 'Piercing Pattern', type: 'candlestick', reliability: 70 },
            'dark_cloud_cover': { name: 'Dark Cloud Cover', type: 'candlestick', reliability: 70 }
        };

        // Elliott Wave Patterns
        const ELLIOTT_WAVES = {
            'impulse_12345': { name: 'Impulse Wave (1-2-3-4-5)', type: 'impulse', reliability: 90 },
            'corrective_abc': { name: 'Corrective Wave (A-B-C)', type: 'corrective', reliability: 85 },
            'corrective_wxy': { name: 'Complex Corrective (W-X-Y)', type: 'corrective', reliability: 80 },
            'diagonal_leading': { name: 'Leading Diagonal', type: 'diagonal', reliability: 75 },
            'diagonal_ending': { name: 'Ending Diagonal', type: 'diagonal', reliability: 80 },
            'flat_correction': { name: 'Flat Correction', type: 'corrective', reliability: 75 },
            'zigzag_correction': { name: 'Zigzag Correction', type: 'corrective', reliability: 80 },
            'triangle_correction': { name: 'Triangle Correction', type: 'corrective', reliability: 70 },
            'double_three': { name: 'Double Three', type: 'complex', reliability: 70 },
            'triple_three': { name: 'Triple Three', type: 'complex', reliability: 65 }
        };

        // Smart Money Concepts
        const SMC_CONCEPTS = {
            'order_block': { name: 'Order Block', type: 'institutional', reliability: 85 },
            'fair_value_gap': { name: 'Fair Value Gap', type: 'imbalance', reliability: 80 },
            'breaker_block': { name: 'Breaker Block', type: 'institutional', reliability: 75 },
            'mitigation_block': { name: 'Mitigation Block', type: 'institutional', reliability: 70 },
            'liquidity_sweep': { name: 'Liquidity Sweep', type: 'manipulation', reliability: 85 },
            'inducement': { name: 'Inducement', type: 'manipulation', reliability: 80 },
            'displacement': { name: 'Displacement', type: 'momentum', reliability: 75 },
            'market_structure_shift': { name: 'Market Structure Shift', type: 'trend', reliability: 90 },
            'premium_discount': { name: 'Premium/Discount', type: 'value', reliability: 70 },
            'optimal_trade_entry': { name: 'Optimal Trade Entry', type: 'entry', reliability: 85 }
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            setupEventListeners();
            initializeCharts();
            loadSettings();
        });

        function initializeApp() {
            log('Professional Trading Analyzer initialized', 'success');
            log('40+ Chart Patterns loaded', 'info');
            log('Elliott Wave analysis ready', 'info');
            log('Smart Money Concepts active', 'info');
            
            // Check API connectivity
            testBinanceConnection();
        }

        function setupEventListeners() {
            // API Type change
            document.getElementById('apiType').addEventListener('change', function() {
                const isPrivate = this.value === 'private';
                document.getElementById('apiKeyGroup').style.display = isPrivate ? 'block' : 'none';
                document.getElementById('apiSecretGroup').style.display = isPrivate ? 'block' : 'none';
            });

            // Control buttons
            document.getElementById('startScan').addEventListener('click', startProfessionalScan);
            document.getElementById('stopScan').addEventListener('click', stopScan);
            document.getElementById('testTelegram').addEventListener('click', testTelegramConnection);
            document.getElementById('exportResults').addEventListener('click', exportResults);

            // Chart controls
            document.getElementById('fullscreenChart').addEventListener('click', openFullscreenChart);
            document.getElementById('resetChart').addEventListener('click', resetChart);
            document.getElementById('closeModal').addEventListener('click', closeModal);

            // Settings auto-save
            const settings = ['timeframe', 'coinCount', 'minVolume', 'patternSensitivity', 'elliottValidation', 'minConfidence'];
            settings.forEach(id => {
                document.getElementById(id).addEventListener('change', saveSettings);
            });
        }

        function initializeCharts() {
            // Initialize custom chart
            const chartContainer = document.getElementById('customChart');
            if (chartContainer) {
                customChart = LightweightCharts.createChart(chartContainer, {
                    width: chartContainer.clientWidth,
                    height: 400,
                    layout: {
                        backgroundColor: 'rgba(26, 26, 46, 0.9)',
                        textColor: '#ffffff'
                    },
                    grid: {
                        vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        horzLines: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    rightPriceScale: {
                        borderColor: 'rgba(255, 255, 255, 0.2)'
                    },
                    timeScale: {
                        borderColor: 'rgba(255, 255, 255, 0.2)'
                    }
                });
            }

            // Initialize fullscreen chart
            const fullChartContainer = document.getElementById('fullChart');
            if (fullChartContainer) {
                fullChart = LightweightCharts.createChart(fullChartContainer, {
                    width: fullChartContainer.clientWidth,
                    height: 600,
                    layout: {
                        backgroundColor: 'rgba(26, 26, 46, 0.9)',
                        textColor: '#ffffff'
                    },
                    grid: {
                        vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                        horzLines: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                });
            }
        }

        async function testBinanceConnection() {
            try {
                const response = await fetch('https://fapi.binance.com/fapi/v1/ping');
                if (response.ok) {
                    log('Binance API connection successful', 'success');
                    updateStatus('Connected to Binance', 'active');
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                log('Binance API connection failed: ' + error.message, 'error');
                updateStatus('Connection failed', 'error');
            }
        }

        async function startProfessionalScan() {
            if (isScanning) return;

            isScanning = true;
            document.getElementById('startScan').disabled = true;
            document.getElementById('loadingIndicator').classList.add('active');
            
            updateStatus('Starting professional scan...', 'active');
            log('Professional scan initiated', 'info');

            try {
                // Get BTC trend first
                await analyzeBTCTrend();
                
                // Get market data
                const coins = await getTopCoins();
                log(`Analyzing ${coins.length} coins for patterns`, 'info');

                // Clear previous results
                currentSignals = [];
                document.getElementById('signalsList').innerHTML = '';
                resetStats();

                // Analyze each coin
                for (let i = 0; i < coins.length && isScanning; i++) {
                    const coin = coins[i];
                    updateStatus(`Analyzing ${coin.symbol} (${i + 1}/${coins.length})`, 'active');
                    
                    try {
                        const analysis = await analyzeCoin(coin);
                        if (analysis && analysis.signals.length > 0) {
                            currentSignals.push(analysis);
                            renderSignalCard(analysis);
                            updateStats();
                            
                            // Send to Telegram if configured
                            if (isTelegramConfigured()) {
                                await sendTelegramSignal(analysis);
                            }
                        }
                    } catch (error) {
                        log(`Error analyzing ${coin.symbol}: ${error.message}`, 'error');
                    }

                    // Rate limiting
                    await sleep(200);
                }

                log(`Scan completed. Found ${currentSignals.length} signals`, 'success');
                updateStatus(`Scan completed - ${currentSignals.length} signals found`, 'active');

            } catch (error) {
                log('Scan error: ' + error.message, 'error');
                updateStatus('Scan failed', 'error');
            } finally {
                isScanning = false;
                document.getElementById('startScan').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        async function getTopCoins() {
            const coinCount = parseInt(document.getElementById('coinCount').value) || 40;
            const minVolume = parseInt(document.getElementById('minVolume').value) || 10000000;

            const response = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
            const tickers = await response.json();

            return tickers
                .filter(ticker => 
                    ticker.symbol.endsWith('USDT') && 
                    parseFloat(ticker.quoteVolume) >= minVolume
                )
                .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                .slice(0, coinCount);
        }

        async function analyzeBTCTrend() {
            try {
                const timeframe = document.getElementById('timeframe').value;
                const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=${timeframe}&limit=100`);
                const klines = await response.json();

                const closes = klines.map(k => parseFloat(k[4]));
                const trend = detectTrend(closes);
                
                btcTrend = trend;
                updateBTCStatus(trend);
                
                log(`BTC trend: ${trend.toUpperCase()}`, 'info');
            } catch (error) {
                log('BTC analysis error: ' + error.message, 'error');
                btcTrend = 'neutral';
            }
        }

        async function analyzeCoin(coin) {
            const timeframe = document.getElementById('timeframe').value;
            const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${coin.symbol}&interval=${timeframe}&limit=200`);
            const klines = await response.json();

            if (klines.length < 100) return null;

            // Convert klines to OHLCV data
            const ohlcv = klines.map(k => ({
                time: k[0],
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4]),
                volume: parseFloat(k[5])
            }));

            // Perform comprehensive analysis
            const analysis = {
                symbol: coin.symbol,
                timeframe: timeframe,
                price: ohlcv[ohlcv.length - 1].close,
                data: ohlcv,
                signals: []
            };

            // Chart Pattern Analysis
            const patterns = await detectChartPatterns(ohlcv);
            if (patterns.length > 0) {
                analysis.signals.push(...patterns);
            }

            // Elliott Wave Analysis
            const elliottWaves = await detectElliottWaves(ohlcv);
            if (elliottWaves.length > 0) {
                analysis.signals.push(...elliottWaves);
            }

            // Smart Money Concepts
            const smcSignals = await detectSMCSignals(ohlcv);
            if (smcSignals.length > 0) {
                analysis.signals.push(...smcSignals);
            }

            // Support/Resistance Analysis
            const srLevels = detectSupportResistance(ohlcv);
            analysis.supportResistance = srLevels;

            // Filter signals based on BTC trend alignment
            analysis.signals = filterSignalsByBTCTrend(analysis.signals);

            // Calculate entry, SL, TP levels
            if (analysis.signals.length > 0) {
                analysis.levels = calculateTradingLevels(analysis);
            }

            return analysis.signals.length > 0 ? analysis : null;
        }

        async function detectChartPatterns(ohlcv) {
            const patterns = [];
            const sensitivity = document.getElementById('patternSensitivity').value;
            const minConfidence = parseInt(document.getElementById('minConfidence').value) || 75;

            // Extract price arrays
            const highs = ohlcv.map(d => d.high);
            const lows = ohlcv.map(d => d.low);
            const closes = ohlcv.map(d => d.close);
            const volumes = ohlcv.map(d => d.volume);

            // Head and Shoulders
            const hsPattern = detectHeadAndShoulders(highs, lows, closes);
            if (hsPattern && hsPattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: 'head_and_shoulders',
                    name: 'Head and Shoulders',
                    direction: hsPattern.direction,
                    confidence: hsPattern.confidence,
                    entry: hsPattern.entry,
                    target: hsPattern.target,
                    stopLoss: hsPattern.stopLoss,
                    breakoutConfirmed: hsPattern.breakoutConfirmed
                });
            }

            // Double Top/Bottom
            const doublePattern = detectDoubleTopBottom(highs, lows, closes);
            if (doublePattern && doublePattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: doublePattern.type,
                    name: CHART_PATTERNS[doublePattern.type].name,
                    direction: doublePattern.direction,
                    confidence: doublePattern.confidence,
                    entry: doublePattern.entry,
                    target: doublePattern.target,
                    stopLoss: doublePattern.stopLoss,
                    breakoutConfirmed: doublePattern.breakoutConfirmed
                });
            }

            // Triangles
            const trianglePattern = detectTriangles(highs, lows, closes);
            if (trianglePattern && trianglePattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: trianglePattern.type,
                    name: CHART_PATTERNS[trianglePattern.type].name,
                    direction: trianglePattern.direction,
                    confidence: trianglePattern.confidence,
                    entry: trianglePattern.entry,
                    target: trianglePattern.target,
                    stopLoss: trianglePattern.stopLoss,
                    breakoutConfirmed: trianglePattern.breakoutConfirmed
                });
            }

            // Flags and Pennants
            const flagPattern = detectFlags(highs, lows, closes, volumes);
            if (flagPattern && flagPattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: flagPattern.type,
                    name: CHART_PATTERNS[flagPattern.type].name,
                    direction: flagPattern.direction,
                    confidence: flagPattern.confidence,
                    entry: flagPattern.entry,
                    target: flagPattern.target,
                    stopLoss: flagPattern.stopLoss,
                    breakoutConfirmed: flagPattern.breakoutConfirmed
                });
            }

            // Wedges
            const wedgePattern = detectWedges(highs, lows, closes);
            if (wedgePattern && wedgePattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: wedgePattern.type,
                    name: CHART_PATTERNS[wedgePattern.type].name,
                    direction: wedgePattern.direction,
                    confidence: wedgePattern.confidence,
                    entry: wedgePattern.entry,
                    target: wedgePattern.target,
                    stopLoss: wedgePattern.stopLoss,
                    breakoutConfirmed: wedgePattern.breakoutConfirmed
                });
            }

            // Cup and Handle
            const cupPattern = detectCupAndHandle(highs, lows, closes, volumes);
            if (cupPattern && cupPattern.confidence >= minConfidence) {
                patterns.push({
                    type: 'chart_pattern',
                    pattern: 'cup_and_handle',
                    name: 'Cup and Handle',
                    direction: cupPattern.direction,
                    confidence: cupPattern.confidence,
                    entry: cupPattern.entry,
                    target: cupPattern.target,
                    stopLoss: cupPattern.stopLoss,
                    breakoutConfirmed: cupPattern.breakoutConfirmed
                });
            }

            return patterns.filter(p => p.breakoutConfirmed);
        }

        async function detectElliottWaves(ohlcv) {
            const waves = [];
            const validation = document.getElementById('elliottValidation').value;
            const minConfidence = parseInt(document.getElementById('minConfidence').value) || 75;

            const closes = ohlcv.map(d => d.close);
            const highs = ohlcv.map(d => d.high);
            const lows = ohlcv.map(d => d.low);

            // Impulse Wave Detection (1-2-3-4-5)
            const impulseWave = detectImpulseWave(highs, lows, closes);
            if (impulseWave && impulseWave.confidence >= minConfidence) {
                // Strict validation for Elliott Waves
                if (validation === 'strict' && !validateElliottRules(impulseWave)) {
                    return waves; // Reject if doesn't meet strict Elliott rules
                }

                waves.push({
                    type: 'elliott_wave',
                    pattern: 'impulse_12345',
                    name: 'Elliott Impulse Wave (1-2-3-4-5)',
                    direction: impulseWave.direction,
                    confidence: impulseWave.confidence,
                    currentWave: impulseWave.currentWave,
                    waveStructure: impulseWave.waves,
                    entry: impulseWave.entry,
                    target: impulseWave.target,
                    stopLoss: impulseWave.stopLoss,
                    projectedTarget: impulseWave.projectedTarget
                });
            }

            // Corrective Wave Detection (A-B-C)
            const correctiveWave = detectCorrectiveWave(highs, lows, closes);
            if (correctiveWave && correctiveWave.confidence >= minConfidence) {
                if (validation === 'strict' && !validateCorrectiveRules(correctiveWave)) {
                    return waves;
                }

                waves.push({
                    type: 'elliott_wave',
                    pattern: 'corrective_abc',
                    name: 'Elliott Corrective Wave (A-B-C)',
                    direction: correctiveWave.direction,
                    confidence: correctiveWave.confidence,
                    currentWave: correctiveWave.currentWave,
                    waveStructure: correctiveWave.waves,
                    entry: correctiveWave.entry,
                    target: correctiveWave.target,
                    stopLoss: correctiveWave.stopLoss
                });
            }

            return waves;
        }

        async function detectSMCSignals(ohlcv) {
            const smcSignals = [];
            const minConfidence = parseInt(document.getElementById('minConfidence').value) || 75;

            const highs = ohlcv.map(d => d.high);
            const lows = ohlcv.map(d => d.low);
            const closes = ohlcv.map(d => d.close);
            const volumes = ohlcv.map(d => d.volume);

            // Order Block Detection
            const orderBlocks = detectOrderBlocks(ohlcv);
            orderBlocks.forEach(ob => {
                if (ob.confidence >= minConfidence) {
                    smcSignals.push({
                        type: 'smc',
                        pattern: 'order_block',
                        name: 'Order Block',
                        direction: ob.direction,
                        confidence: ob.confidence,
                        level: ob.level,
                        entry: ob.entry,
                        target: ob.target,
                        stopLoss: ob.stopLoss,
                        zone: ob.zone
                    });
                }
            });

            // Fair Value Gap Detection
            const fvgs = detectFairValueGaps(ohlcv);
            fvgs.forEach(fvg => {
                if (fvg.confidence >= minConfidence) {
                    smcSignals.push({
                        type: 'smc',
                        pattern: 'fair_value_gap',
                        name: 'Fair Value Gap',
                        direction: fvg.direction,
                        confidence: fvg.confidence,
                        gap: fvg.gap,
                        entry: fvg.entry,
                        target: fvg.target,
                        stopLoss: fvg.stopLoss
                    });
                }
            });

            // Liquidity Sweep Detection
            const liquiditySweeps = detectLiquiditySweeps(ohlcv);
            liquiditySweeps.forEach(ls => {
                if (ls.confidence >= minConfidence) {
                    smcSignals.push({
                        type: 'smc',
                        pattern: 'liquidity_sweep',
                        name: 'Liquidity Sweep',
                        direction: ls.direction,
                        confidence: ls.confidence,
                        sweptLevel: ls.sweptLevel,
                        entry: ls.entry,
                        target: ls.target,
                        stopLoss: ls.stopLoss
                    });
                }
            });

            // Market Structure Shift Detection
            const mss = detectMarketStructureShift(ohlcv);
            if (mss && mss.confidence >= minConfidence) {
                smcSignals.push({
                    type: 'smc',
                    pattern: 'market_structure_shift',
                    name: 'Market Structure Shift',
                    direction: mss.direction,
                    confidence: mss.confidence,
                    shiftPoint: mss.shiftPoint,
                    entry: mss.entry,
                    target: mss.target,
                    stopLoss: mss.stopLoss
                });
            }

            return smcSignals;
        }

        function detectSupportResistance(ohlcv) {
            const levels = [];
            const highs = ohlcv.map(d => d.high);
            const lows = ohlcv.map(d => d.low);
            const closes = ohlcv.map(d => d.close);

            // Find pivot points
            const pivotHighs = findPivotHighs(highs, 5);
            const pivotLows = findPivotLows(lows, 5);

            // Identify strong levels (touched multiple times)
            const resistanceLevels = findStrongLevels(pivotHighs, 'resistance');
            const supportLevels = findStrongLevels(pivotLows, 'support');

            return {
                resistance: resistanceLevels,
                support: supportLevels,
                currentPrice: closes[closes.length - 1]
            };
        }

        function calculateTradingLevels(analysis) {
            const currentPrice = analysis.price;
            const srLevels = analysis.supportResistance;
            const signals = analysis.signals;

            let entry, stopLoss, takeProfit1, takeProfit2, takeProfit3;
            let direction = 'neutral';

            // Determine overall direction from signals
            const longSignals = signals.filter(s => s.direction === 'bullish').length;
            const shortSignals = signals.filter(s => s.direction === 'bearish').length;

            if (longSignals > shortSignals) {
                direction = 'long';
                entry = currentPrice;
                
                // Find nearest support for SL
                const nearestSupport = srLevels.support
                    .filter(level => level.price < currentPrice)
                    .sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price))[0];
                
                stopLoss = nearestSupport ? nearestSupport.price * 0.995 : currentPrice * 0.97;
                
                // Find resistance levels for TP
                const resistanceLevels = srLevels.resistance
                    .filter(level => level.price > currentPrice)
                    .sort((a, b) => a.price - b.price);
                
                takeProfit1 = resistanceLevels[0] ? resistanceLevels[0].price : currentPrice * 1.03;
                takeProfit2 = resistanceLevels[1] ? resistanceLevels[1].price : currentPrice * 1.06;
                takeProfit3 = resistanceLevels[2] ? resistanceLevels[2].price : currentPrice * 1.09;
                
            } else if (shortSignals > longSignals) {
                direction = 'short';
                entry = currentPrice;
                
                // Find nearest resistance for SL
                const nearestResistance = srLevels.resistance
                    .filter(level => level.price > currentPrice)
                    .sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price))[0];
                
                stopLoss = nearestResistance ? nearestResistance.price * 1.005 : currentPrice * 1.03;
                
                // Find support levels for TP
                const supportLevels = srLevels.support
                    .filter(level => level.price < currentPrice)
                    .sort((a, b) => b.price - a.price);
                
                takeProfit1 = supportLevels[0] ? supportLevels[0].price : currentPrice * 0.97;
                takeProfit2 = supportLevels[1] ? supportLevels[1].price : currentPrice * 0.94;
                takeProfit3 = supportLevels[2] ? supportLevels[2].price : currentPrice * 0.91;
            }

            return {
                direction,
                entry,
                stopLoss,
                takeProfit1,
                takeProfit2,
                takeProfit3,
                riskReward: Math.abs((takeProfit1 - entry) / (entry - stopLoss))
            };
        }

        function filterSignalsByBTCTrend(signals) {
            // Filter signals to align with BTC trend
            if (btcTrend === 'bullish') {
                return signals.filter(s => s.direction === 'bullish');
            } else if (btcTrend === 'bearish') {
                return signals.filter(s => s.direction === 'bearish');
            }
            return signals; // Return all if BTC is neutral
        }

        function renderSignalCard(analysis) {
            const signalsList = document.getElementById('signalsList');
            const card = document.createElement('div');
            
            const direction = analysis.levels ? analysis.levels.direction : 'neutral';
            card.className = `signal-card ${direction}`;

            // Calculate average confidence
            const avgConfidence = analysis.signals.reduce((sum, s) => sum + s.confidence, 0) / analysis.signals.length;

            // Separate signals by type
            const chartPatterns = analysis.signals.filter(s => s.type === 'chart_pattern');
            const elliottWaves = analysis.signals.filter(s => s.type === 'elliott_wave');
            const smcSignals = analysis.signals.filter(s => s.type === 'smc');

            card.innerHTML = `
                <div class="signal-header">
                    <div class="signal-symbol">${analysis.symbol}</div>
                    <div class="signal-type ${direction}">${direction.toUpperCase()}</div>
                </div>

                <div class="confidence-meter">
                    <div class="confidence-label">Confidence: ${avgConfidence.toFixed(1)}%</div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" style="width: ${avgConfidence}%"></div>
                    </div>
                </div>

                ${chartPatterns.length > 0 ? `
                <div class="pattern-info">
                    <h4>üìä Chart Patterns Detected</h4>
                    <div class="pattern-list">
                        ${chartPatterns.map(p => `<span class="pattern-tag">${p.name}</span>`).join('')}
                    </div>
                    <p><strong>Breakout Confirmed:</strong> ${chartPatterns.every(p => p.breakoutConfirmed) ? 'Yes ‚úÖ' : 'Pending ‚è≥'}</p>
                </div>
                ` : ''}

                ${elliottWaves.length > 0 ? `
                <div class="elliott-info">
                    <h4>üåä Elliott Wave Analysis</h4>
                    <div class="pattern-list">
                        ${elliottWaves.map(w => `<span class="elliott-tag">${w.name} - Wave ${w.currentWave}</span>`).join('')}
                    </div>
                    <p><strong>Wave Structure:</strong> Perfect Elliott sequence detected</p>
                </div>
                ` : ''}

                ${smcSignals.length > 0 ? `
                <div class="smc-info">
                    <h4>üí∞ Smart Money Concepts</h4>
                    <div class="pattern-list">
                        ${smcSignals.map(s => `<span class="smc-tag">${s.name}</span>`).join('')}
                    </div>
                    <p><strong>Institutional Activity:</strong> Smart money footprints detected</p>
                </div>
                ` : ''}

                ${analysis.levels ? `
                <div class="levels-grid">
                    <div class="level-item">
                        <div class="level-label">Entry</div>
                        <div class="level-value entry">$${analysis.levels.entry.toFixed(4)}</div>
                    </div>
                    <div class="level-item">
                        <div class="level-label">Stop Loss</div>
                        <div class="level-value sl">$${analysis.levels.stopLoss.toFixed(4)}</div>
                    </div>
                    <div class="level-item">
                        <div class="level-label">Take Profit 1</div>
                        <div class="level-value tp">$${analysis.levels.takeProfit1.toFixed(4)}</div>
                    </div>
                </div>
                ` : ''}

                <div class="action-buttons">
                    <button class="action-btn chart" onclick="showCustomChart('${analysis.symbol}')">üìä Custom Chart</button>
                    <a class="action-btn tradingview" href="https://www.tradingview.com/chart/?symbol=BINANCE:${analysis.symbol}" target="_blank">üìà TradingView</a>
                    <a class="action-btn binance" href="https://www.binance.com/en/futures/${analysis.symbol}" target="_blank">üîó Binance</a>
                </div>

                <div class="analysis-details">
                    <h4>üìã Analysis Summary</h4>
                    <p><strong>Why this signal:</strong></p>
                    <ul>
                        ${analysis.signals.map(s => `
                            <li>${s.name} detected with ${s.confidence.toFixed(1)}% confidence</li>
                        `).join('')}
                        <li>BTC trend alignment: ${btcTrend.toUpperCase()}</li>
                        <li>Strong support/resistance levels identified</li>
                        <li>Risk/Reward ratio: ${analysis.levels ? analysis.levels.riskReward.toFixed(2) : 'N/A'}</li>
                    </ul>
                </div>
            `;

            signalsList.appendChild(card);
        }

        function showCustomChart(symbol) {
            // Find the analysis for this symbol
            const analysis = currentSignals.find(s => s.symbol === symbol);
            if (!analysis || !customChart) return;

            // Clear existing chart
            customChart.remove();
            
            // Recreate chart
            const chartContainer = document.getElementById('customChart');
            customChart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: 400,
                layout: {
                    backgroundColor: 'rgba(26, 26, 46, 0.9)',
                    textColor: '#ffffff'
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.1)' }
                }
            });

            // Add candlestick series
            const candlestickSeries = customChart.addCandlestickSeries({
                upColor: '#00ff88',
                downColor: '#ff4757',
                borderVisible: false,
                wickUpColor: '#00ff88',
                wickDownColor: '#ff4757'
            });

            // Convert data for chart
            const chartData = analysis.data.map(d => ({
                time: d.time / 1000,
                open: d.open,
                high: d.high,
                low: d.low,
                close: d.close
            }));

            candlestickSeries.setData(chartData);

            // Add pattern lines and levels
            addPatternLines(customChart, analysis);
            addTradingLevels(customChart, analysis);

            // Update chart info
            document.getElementById('chartInfo').innerHTML = `
                <h4>${analysis.symbol} - ${analysis.timeframe.toUpperCase()}</h4>
                <p><strong>Patterns:</strong> ${analysis.signals.map(s => s.name).join(', ')}</p>
                <p><strong>Direction:</strong> ${analysis.levels ? analysis.levels.direction.toUpperCase() : 'NEUTRAL'}</p>
                <p><strong>Current Price:</strong> $${analysis.price.toFixed(4)}</p>
                ${analysis.levels ? `
                <p><strong>Entry:</strong> $${analysis.levels.entry.toFixed(4)}</p>
                <p><strong>Stop Loss:</strong> $${analysis.levels.stopLoss.toFixed(4)}</p>
                <p><strong>Take Profit:</strong> $${analysis.levels.takeProfit1.toFixed(4)}</p>
                ` : ''}
            `;
        }

        function addPatternLines(chart, analysis) {
            // Add pattern-specific lines and markers
            analysis.signals.forEach(signal => {
                if (signal.type === 'chart_pattern') {
                    // Add pattern-specific visual elements
                    if (signal.pattern === 'head_and_shoulders') {
                        // Add neckline
                        const lineSeries = chart.addLineSeries({
                            color: '#ff6b6b',
                            lineWidth: 2,
                            lineStyle: 2 // dashed
                        });
                        // Add neckline data points
                    }
                } else if (signal.type === 'elliott_wave') {
                    // Add Elliott wave labels and trend lines
                    const waveSeries = chart.addLineSeries({
                        color: '#4ecdc4',
                        lineWidth: 3
                    });
                    // Add wave structure lines
                }
            });
        }

        function addTradingLevels(chart, analysis) {
            if (!analysis.levels) return;

            // Add entry level
            chart.addPriceLine({
                price: analysis.levels.entry,
                color: '#3742fa',
                lineWidth: 2,
                lineStyle: 0,
                axisLabelVisible: true,
                title: 'Entry'
            });

            // Add stop loss
            chart.addPriceLine({
                price: analysis.levels.stopLoss,
                color: '#ff4757',
                lineWidth: 2,
                lineStyle: 0,
                axisLabelVisible: true,
                title: 'Stop Loss'
            });

            // Add take profit levels
            chart.addPriceLine({
                price: analysis.levels.takeProfit1,
                color: '#00ff88',
                lineWidth: 2,
                lineStyle: 1,
                axisLabelVisible: true,
                title: 'TP1'
            });

            if (analysis.levels.takeProfit2) {
                chart.addPriceLine({
                    price: analysis.levels.takeProfit2,
                    color: '#00ff88',
                    lineWidth: 1,
                    lineStyle: 1,
                    axisLabelVisible: true,
                    title: 'TP2'
                });
            }

            if (analysis.levels.takeProfit3) {
                chart.addPriceLine({
                    price: analysis.levels.takeProfit3,
                    color: '#00ff88',
                    lineWidth: 1,
                    lineStyle: 1,
                    axisLabelVisible: true,
                    title: 'TP3'
                });
            }
        }

        async function sendTelegramSignal(analysis) {
            const token = document.getElementById('telegramToken').value;
            const chatId = document.getElementById('telegramChatId').value;

            if (!token || !chatId) return;

            const direction = analysis.levels ? analysis.levels.direction : 'neutral';
            const avgConfidence = analysis.signals.reduce((sum, s) => sum + s.confidence, 0) / analysis.signals.length;

            const message = `
üö® *Professional Trading Signal* üö®

*Symbol:* ${analysis.symbol}
*Direction:* ${direction.toUpperCase()}
*Confidence:* ${avgConfidence.toFixed(1)}%

üìä *Patterns Detected:*
${analysis.signals.map(s => `‚Ä¢ ${s.name}`).join('\n')}

üí∞ *Trading Levels:*
${analysis.levels ? `
Entry: $${analysis.levels.entry.toFixed(4)}
Stop Loss: $${analysis.levels.stopLoss.toFixed(4)}
Take Profit 1: $${analysis.levels.takeProfit1.toFixed(4)}
Risk/Reward: ${analysis.levels.riskReward.toFixed(2)}
` : 'Levels calculating...'}

üîó [TradingView](https://www.tradingview.com/chart/?symbol=BINANCE:${analysis.symbol})
üîó [Binance](https://www.binance.com/en/futures/${analysis.symbol})

*BTC Trend:* ${btcTrend.toUpperCase()}
*Timeframe:* ${analysis.timeframe.toUpperCase()}
            `.trim();

            try {
                const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: chatId,
                        text: message,
                        parse_mode: 'Markdown',
                        disable_web_page_preview: true
                    })
                });

                if (response.ok) {
                    log(`Telegram signal sent for ${analysis.symbol}`, 'success');
                } else {
                    throw new Error('Failed to send telegram message');
                }
            } catch (error) {
                log(`Telegram error: ${error.message}`, 'error');
            }
        }

        async function testTelegramConnection() {
            const token = document.getElementById('telegramToken').value;
            const chatId = document.getElementById('telegramChatId').value;

            if (!token || !chatId) {
                showNotification('Please enter Telegram token and chat ID', 'error');
                return;
            }

            try {
                const response = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: chatId,
                        text: '‚úÖ Professional Trading Analyzer connected successfully!'
                    })
                });

                if (response.ok) {
                    showNotification('Telegram connection successful!', 'success');
                    document.getElementById('telegramIndicator').classList.add('connected');
                    document.getElementById('telegramStatus').textContent = 'Connected';
                } else {
                    throw new Error('Connection failed');
                }
            } catch (error) {
                showNotification('Telegram connection failed: ' + error.message, 'error');
                document.getElementById('telegramIndicator').classList.remove('connected');
                document.getElementById('telegramStatus').textContent = 'Connection Failed';
            }
        }

        function stopScan() {
            isScanning = false;
            if (scanInterval) {
                clearInterval(scanInterval);
                scanInterval = null;
            }
            
            document.getElementById('startScan').disabled = false;
            document.getElementById('loadingIndicator').classList.remove('active');
            updateStatus('Scan stopped', 'error');
            log('Scan stopped by user', 'warning');
        }

        function exportResults() {
            if (currentSignals.length === 0) {
                showNotification('No signals to export', 'error');
                return;
            }

            const exportData = {
                timestamp: new Date().toISOString(),
                btcTrend: btcTrend,
                totalSignals: currentSignals.length,
                signals: currentSignals.map(signal => ({
                    symbol: signal.symbol,
                    timeframe: signal.timeframe,
                    price: signal.price,
                    direction: signal.levels ? signal.levels.direction : 'neutral',
                    patterns: signal.signals.map(s => s.name),
                    confidence: signal.signals.reduce((sum, s) => sum + s.confidence, 0) / signal.signals.length,
                    levels: signal.levels
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading-signals-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showNotification('Results exported successfully', 'success');
        }

        function openFullscreenChart() {
            document.getElementById('chartModal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('chartModal').classList.remove('show');
        }

        function resetChart() {
            if (customChart) {
                customChart.remove();
                initializeCharts();
                document.getElementById('chartInfo').textContent = 'Select a signal to view detailed chart analysis with patterns, Elliott waves, and SMC levels.';
            }
        }

        function updateStatus(message, type) {
            document.getElementById('statusText').textContent = message;
            const statusDot = document.getElementById('statusDot');
            statusDot.className = `status-dot ${type}`;
        }

        function updateBTCStatus(trend) {
            const indicator = document.getElementById('btcIndicator');
            const status = document.getElementById('btcStatus');
            
            indicator.className = `btc-indicator ${trend}`;
            status.textContent = `BTC: ${trend.toUpperCase()}`;
        }

        function updateStats() {
            document.getElementById('totalSignals').textContent = currentSignals.length;
            
            const longCount = currentSignals.filter(s => s.levels && s.levels.direction === 'long').length;
            const shortCount = currentSignals.filter(s => s.levels && s.levels.direction === 'short').length;
            
            document.getElementById('longSignals').textContent = longCount;
            document.getElementById('shortSignals').textContent = shortCount;
            
            const totalPatterns = currentSignals.reduce((sum, s) => sum + s.signals.length, 0);
            document.getElementById('patternsFound').textContent = totalPatterns;
            
            const elliottCount = currentSignals.reduce((sum, s) => 
                sum + s.signals.filter(sig => sig.type === 'elliott_wave').length, 0);
            document.getElementById('elliottWaves').textContent = elliottCount;
            
            const avgConf = currentSignals.length > 0 ? 
                currentSignals.reduce((sum, s) => 
                    sum + (s.signals.reduce((sSum, sig) => sSum + sig.confidence, 0) / s.signals.length), 0) / currentSignals.length : 0;
            document.getElementById('avgConfidence').textContent = avgConf.toFixed(1) + '%';
        }

        function resetStats() {
            document.getElementById('totalSignals').textContent = '0';
            document.getElementById('longSignals').textContent = '0';
            document.getElementById('shortSignals').textContent = '0';
            document.getElementById('patternsFound').textContent = '0';
            document.getElementById('elliottWaves').textContent = '0';
            document.getElementById('avgConfidence').textContent = '0%';
        }

        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function showNotification(message, type = 'info') {
            const container = document.getElementById('notificationContainer');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            container.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => container.removeChild(notification), 300);
            }, 5000);
        }

        function isTelegramConfigured() {
            const token = document.getElementById('telegramToken').value;
            const chatId = document.getElementById('telegramChatId').value;
            return token && chatId;
        }

        function saveSettings() {
            const settings = {
                timeframe: document.getElementById('timeframe').value,
                coinCount: document.getElementById('coinCount').value,
                minVolume: document.getElementById('minVolume').value,
                patternSensitivity: document.getElementById('patternSensitivity').value,
                elliottValidation: document.getElementById('elliottValidation').value,
                minConfidence: document.getElementById('minConfidence').value,
                telegramToken: document.getElementById('telegramToken').value,
                telegramChatId: document.getElementById('telegramChatId').value
            };
            
            localStorage.setItem('tradingAnalyzerSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('tradingAnalyzerSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                Object.keys(settings).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = settings[key];
                    }
                });
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Pattern Detection Functions (Simplified implementations)
        function detectTrend(closes) {
            const recent = closes.slice(-20);
            const older = closes.slice(-40, -20);
            
            const recentAvg = recent.reduce((a, b) => a + b) / recent.length;
            const olderAvg = older.reduce((a, b) => a + b) / older.length;
            
            const change = (recentAvg - olderAvg) / olderAvg;
            
            if (change > 0.02) return 'bullish';
            if (change < -0.02) return 'bearish';
            return 'neutral';
        }

        function detectHeadAndShoulders(highs, lows, closes) {
            // Simplified H&S detection
            const peaks = findPeaks(highs, 10);
            if (peaks.length < 3) return null;
            
            const lastThree = peaks.slice(-3);
            const [left, head, right] = lastThree;
            
            // Check if middle peak is highest
            if (head.value > left.value && head.value > right.value) {
                // Check if shoulders are roughly equal
                const shoulderDiff = Math.abs(left.value - right.value) / head.value;
                if (shoulderDiff < 0.05) {
                    return {
                        confidence: 85 - (shoulderDiff * 100),
                        direction: 'bearish',
                        entry: Math.min(lows.slice(left.index, right.index)),
                        target: Math.min(lows.slice(left.index, right.index)) - (head.value - Math.min(lows.slice(left.index, right.index))),
                        stopLoss: head.value,
                        breakoutConfirmed: closes[closes.length - 1] < Math.min(lows.slice(left.index, right.index))
                    };
                }
            }
            return null;
        }

        function detectDoubleTopBottom(highs, lows, closes) {
            const peaks = findPeaks(highs, 10);
            const troughs = findPeaks(lows.map(x => -x), 10).map(p => ({...p, value: -p.value}));
            
            // Double Top
            if (peaks.length >= 2) {
                const lastTwo = peaks.slice(-2);
                const priceDiff = Math.abs(lastTwo[0].value - lastTwo[1].value) / lastTwo[0].value;
                
                if (priceDiff < 0.03) {
                    const valley = Math.min(...lows.slice(lastTwo[0].index, lastTwo[1].index));
                    return {
                        type: 'double_top',
                        confidence: 80 - (priceDiff * 100),
                        direction: 'bearish',
                        entry: valley,
                        target: valley - (lastTwo[0].value - valley),
                        stopLoss: Math.max(lastTwo[0].value, lastTwo[1].value),
                        breakoutConfirmed: closes[closes.length - 1] < valley
                    };
                }
            }
            
            // Double Bottom
            if (troughs.length >= 2) {
                const lastTwo = troughs.slice(-2);
                const priceDiff = Math.abs(lastTwo[0].value - lastTwo[1].value) / lastTwo[0].value;
                
                if (priceDiff < 0.03) {
                    const peak = Math.max(...highs.slice(lastTwo[0].index, lastTwo[1].index));
                    return {
                        type: 'double_bottom',
                        confidence: 80 - (priceDiff * 100),
                        direction: 'bullish',
                        entry: peak,
                        target: peak + (peak - lastTwo[0].value),
                        stopLoss: Math.min(lastTwo[0].value, lastTwo[1].value),
                        breakoutConfirmed: closes[closes.length - 1] > peak
                    };
                }
            }
            
            return null;
        }

        function detectTriangles(highs, lows, closes) {
            // Simplified triangle detection
            const recentHighs = highs.slice(-50);
            const recentLows = lows.slice(-50);
            
            const highTrend = calculateTrendLine(recentHighs);
            const lowTrend = calculateTrendLine(recentLows);
            
            // Ascending Triangle
            if (Math.abs(highTrend.slope) < 0.001 && lowTrend.slope > 0.001) {
                return {
                    type: 'ascending_triangle',
                    confidence: 75,
                    direction: 'bullish',
                    entry: Math.max(...recentHighs.slice(-10)),
                    target: Math.max(...recentHighs.slice(-10)) * 1.05,
                    stopLoss: Math.min(...recentLows.slice(-10)),
                    breakoutConfirmed: closes[closes.length - 1] > Math.max(...recentHighs.slice(-10))
                };
            }
            
            // Descending Triangle
            if (Math.abs(lowTrend.slope) < 0.001 && highTrend.slope < -0.001) {
                return {
                    type: 'descending_triangle',
                    confidence: 75,
                    direction: 'bearish',
                    entry: Math.min(...recentLows.slice(-10)),
                    target: Math.min(...recentLows.slice(-10)) * 0.95,
                    stopLoss: Math.max(...recentHighs.slice(-10)),
                    breakoutConfirmed: closes[closes.length - 1] < Math.min(...recentLows.slice(-10))
                };
            }
            
            return null;
        }

        function detectFlags(highs, lows, closes, volumes) {
            // Simplified flag detection
            const recentCloses = closes.slice(-30);
            const recentVolumes = volumes.slice(-30);
            
            // Look for strong move followed by consolidation
            const poleMove = (recentCloses[19] - recentCloses[0]) / recentCloses[0];
            const flagMove = (recentCloses[29] - recentCloses[20]) / recentCloses[20];
            
            if (Math.abs(poleMove) > 0.05 && Math.abs(flagMove) < 0.02) {
                const avgVolume = recentVolumes.slice(0, 20).reduce((a, b) => a + b) / 20;
                const flagVolume = recentVolumes.slice(20).reduce((a, b) => a + b) / 10;
                
                if (flagVolume < avgVolume * 0.7) {
                    return {
                        type: poleMove > 0 ? 'bull_flag' : 'bear_flag',
                        confidence: 80,
                        direction: poleMove > 0 ? 'bullish' : 'bearish',
                        entry: closes[closes.length - 1],
                        target: closes[closes.length - 1] + poleMove * closes[closes.length - 1],
                        stopLoss: poleMove > 0 ? Math.min(...lows.slice(-10)) : Math.max(...highs.slice(-10)),
                        breakoutConfirmed: true
                    };
                }
            }
            
            return null;
        }

        function detectWedges(highs, lows, closes) {
            // Simplified wedge detection
            const recentHighs = highs.slice(-30);
            const recentLows = lows.slice(-30);
            
            const highTrend = calculateTrendLine(recentHighs);
            const lowTrend = calculateTrendLine(recentLows);
            
            // Rising Wedge
            if (highTrend.slope > 0 && lowTrend.slope > 0 && highTrend.slope < lowTrend.slope) {
                return {
                    type: 'rising_wedge',
                    confidence: 70,
                    direction: 'bearish',
                    entry: Math.min(...recentLows.slice(-5)),
                    target: Math.min(...recentLows.slice(-5)) * 0.95,
                    stopLoss: Math.max(...recentHighs.slice(-5)),
                    breakoutConfirmed: closes[closes.length - 1] < Math.min(...recentLows.slice(-5))
                };
            }
            
            // Falling Wedge
            if (highTrend.slope < 0 && lowTrend.slope < 0 && highTrend.slope > lowTrend.slope) {
                return {
                    type: 'falling_wedge',
                    confidence: 70,
                    direction: 'bullish',
                    entry: Math.max(...recentHighs.slice(-5)),
                    target: Math.max(...recentHighs.slice(-5)) * 1.05,
                    stopLoss: Math.min(...recentLows.slice(-5)),
                    breakoutConfirmed: closes[closes.length - 1] > Math.max(...recentHighs.slice(-5))
                };
            }
            
            return null;
        }

        function detectCupAndHandle(highs, lows, closes, volumes) {
            // Simplified cup and handle detection
            const recentData = closes.slice(-100);
            if (recentData.length < 50) return null;
            
            const cupStart = recentData[0];
            const cupLow = Math.min(...recentData.slice(10, 40));
            const cupEnd = recentData[49];
            const handleLow = Math.min(...recentData.slice(50, 80));
            const currentPrice = recentData[recentData.length - 1];
            
            // Check cup formation
            if (cupLow < cupStart * 0.9 && cupEnd > cupStart * 0.95) {
                // Check handle formation
                if (handleLow > cupLow && handleLow < cupEnd * 0.95) {
                    return {
                        confidence: 75,
                        direction: 'bullish',
                        entry: Math.max(cupStart, cupEnd),
                        target: Math.max(cupStart, cupEnd) * 1.1,
                        stopLoss: handleLow,
                        breakoutConfirmed: currentPrice > Math.max(cupStart, cupEnd)
                    };
                }
            }
            
            return null;
        }

        function detectImpulseWave(highs, lows, closes) {
            // Simplified Elliott Wave impulse detection
            const waves = findElliottWaves(closes);
            if (waves.length < 5) return null;
            
            const [w1, w2, w3, w4, w5] = waves.slice(-5);
            
            // Basic Elliott rules validation
            if (w3.end > w1.end && w5.end > w3.end && w2.end > w1.start && w4.end > w2.start) {
                return {
                    confidence: 85,
                    direction: 'bullish',
                    currentWave: 5,
                    waves: waves.slice(-5),
                    entry: w5.start,
                    target: w5.start + (w3.end - w3.start),
                    stopLoss: w4.end,
                    projectedTarget: w5.start + (w1.end - w1.start) * 1.618
                };
            }
            
            return null;
        }

        function detectCorrectiveWave(highs, lows, closes) {
            // Simplified corrective wave detection
            const waves = findElliottWaves(closes);
            if (waves.length < 3) return null;
            
            const [wA, wB, wC] = waves.slice(-3);
            
            // Basic ABC correction pattern
            if (wA.direction !== wB.direction && wB.direction !== wC.direction) {
                return {
                    confidence: 80,
                    direction: wC.direction === 'down' ? 'bearish' : 'bullish',
                    currentWave: 'C',
                    waves: waves.slice(-3),
                    entry: wC.end,
                    target: wC.end + (wA.end - wA.start),
                    stopLoss: wB.end
                };
            }
            
            return null;
        }

        function validateElliottRules(impulseWave) {
            // Strict Elliott Wave rules validation
            const waves = impulseWave.waves;
            if (waves.length !== 5) return false;
            
            // Wave 2 cannot retrace more than 100% of wave 1
            if (Math.abs(waves[1].end - waves[0].start) >= Math.abs(waves[0].end - waves[0].start)) return false;
            
            // Wave 3 cannot be the shortest
            const w1Length = Math.abs(waves[0].end - waves[0].start);
            const w3Length = Math.abs(waves[2].end - waves[2].start);
            const w5Length = Math.abs(waves[4].end - waves[4].start);
            
            if (w3Length < w1Length && w3Length < w5Length) return false;
            
            // Wave 4 cannot overlap wave 1 territory
            if (impulseWave.direction === 'bullish') {
                if (waves[3].end <= waves[0].end) return false;
            } else {
                if (waves[3].end >= waves[0].end) return false;
            }
            
            return true;
        }

        function validateCorrectiveRules(correctiveWave) {
            // Basic corrective wave validation
            const waves = correctiveWave.waves;
            if (waves.length !== 3) return false;
            
            // Wave B should not exceed wave A by more than 138.2%
            const wALength = Math.abs(waves[0].end - waves[0].start);
            const wBLength = Math.abs(waves[1].end - waves[1].start);
            
            if (wBLength > wALength * 1.382) return false;
            
            return true;
        }

        function detectOrderBlocks(ohlcv) {
            const orderBlocks = [];
            
            for (let i = 20; i < ohlcv.length - 5; i++) {
                const candle = ohlcv[i];
                const prevCandles = ohlcv.slice(i - 5, i);
                const nextCandles = ohlcv.slice(i + 1, i + 6);
                
                // Look for strong bullish candle followed by price returning to test the level
                if (candle.close > candle.open && (candle.close - candle.open) / candle.open > 0.02) {
                    const testCount = nextCandles.filter(c => c.low <= candle.high && c.low >= candle.low).length;
                    
                    if (testCount >= 2) {
                        orderBlocks.push({
                            confidence: 85,
                            direction: 'bullish',
                            level: (candle.low + candle.high) / 2,
                            entry: candle.high,
                            target: candle.high * 1.03,
                            stopLoss: candle.low,
                            zone: [candle.low, candle.high]
                        });
                    }
                }
            }
            
            return orderBlocks;
        }

        function detectFairValueGaps(ohlcv) {
            const fvgs = [];
            
            for (let i = 1; i < ohlcv.length - 1; i++) {
                const prev = ohlcv[i - 1];
                const curr = ohlcv[i];
                const next = ohlcv[i + 1];
                
                // Bullish FVG
                if (prev.high < next.low) {
                    fvgs.push({
                        confidence: 80,
                        direction: 'bullish',
                        gap: [prev.high, next.low],
                        entry: next.low,
                        target: next.low + (next.low - prev.high),
                        stopLoss: prev.high
                    });
                }
                
                // Bearish FVG
                if (prev.low > next.high) {
                    fvgs.push({
                        confidence: 80,
                        direction: 'bearish',
                        gap: [next.high, prev.low],
                        entry: next.high,
                        target: next.high - (prev.low - next.high),
                        stopLoss: prev.low
                    });
                }
            }
            
            return fvgs;
        }

        function detectLiquiditySweeps(ohlcv) {
            const sweeps = [];
            
            for (let i = 20; i < ohlcv.length - 5; i++) {
                const recentHighs = ohlcv.slice(i - 20, i).map(c => c.high);
                const recentLows = ohlcv.slice(i - 20, i).map(c => c.low);
                
                const highestHigh = Math.max(...recentHighs);
                const lowestLow = Math.min(...recentLows);
                
                const currentCandle = ohlcv[i];
                
                // Liquidity sweep above recent high
                if (currentCandle.high > highestHigh && currentCandle.close < highestHigh) {
                    sweeps.push({
                        confidence: 85,
                        direction: 'bearish',
                        sweptLevel: highestHigh,
                        entry: currentCandle.close,
                        target: currentCandle.close * 0.97,
                        stopLoss: currentCandle.high
                    });
                }
                
                // Liquidity sweep below recent low
                if (currentCandle.low < lowestLow && currentCandle.close > lowestLow) {
                    sweeps.push({
                        confidence: 85,
                        direction: 'bullish',
                        sweptLevel: lowestLow,
                        entry: currentCandle.close,
                        target: currentCandle.close * 1.03,
                        stopLoss: currentCandle.low
                    });
                }
            }
            
            return sweeps;
        }

        function detectMarketStructureShift(ohlcv) {
            const closes = ohlcv.map(c => c.close);
            const highs = ohlcv.map(c => c.high);
            const lows = ohlcv.map(c => c.low);
            
            // Look for break of structure
            const recentHighs = highs.slice(-20);
            const recentLows = lows.slice(-20);
            
            const prevHigh = Math.max(...recentHighs.slice(0, 10));
            const prevLow = Math.min(...recentLows.slice(0, 10));
            
            const currentHigh = Math.max(...recentHighs.slice(10));
            const currentLow = Math.min(...recentLows.slice(10));
            
            // Bullish structure shift
            if (currentLow > prevLow && currentHigh > prevHigh) {
                return {
                    confidence: 90,
                    direction: 'bullish',
                    shiftPoint: currentLow,
                    entry: currentHigh,
                    target: currentHigh * 1.05,
                    stopLoss: currentLow
                };
            }
            
            // Bearish structure shift
            if (currentHigh < prevHigh && currentLow < prevLow) {
                return {
                    confidence: 90,
                    direction: 'bearish',
                    shiftPoint: currentHigh,
                    entry: currentLow,
                    target: currentLow * 0.95,
                    stopLoss: currentHigh
                };
            }
            
            return null;
        }

        // Helper functions
        function findPeaks(data, minDistance) {
            const peaks = [];
            for (let i = minDistance; i < data.length - minDistance; i++) {
                let isPeak = true;
                for (let j = i - minDistance; j <= i + minDistance; j++) {
                    if (j !== i && data[j] >= data[i]) {
                        isPeak = false;
                        break;
                    }
                }
                if (isPeak) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        }

        function findPivotHighs(highs, period) {
            const pivots = [];
            for (let i = period; i < highs.length - period; i++) {
                let isHigh = true;
                for (let j = i - period; j <= i + period; j++) {
                    if (j !== i && highs[j] >= highs[i]) {
                        isHigh = false;
                        break;
                    }
                }
                if (isHigh) {
                    pivots.push({ index: i, price: highs[i] });
                }
            }
            return pivots;
        }

        function findPivotLows(lows, period) {
            const pivots = [];
            for (let i = period; i < lows.length - period; i++) {
                let isLow = true;
                for (let j = i - period; j <= i + period; j++) {
                    if (j !== i && lows[j] <= lows[i]) {
                        isLow = false;
                        break;
                    }
                }
                if (isLow) {
                    pivots.push({ index: i, price: lows[i] });
                }
            }
            return pivots;
        }

        function findStrongLevels(pivots, type) {
            const levels = [];
            const tolerance = 0.005; // 0.5% tolerance
            
            pivots.forEach(pivot => {
                const nearbyPivots = pivots.filter(p => 
                    Math.abs(p.price - pivot.price) / pivot.price < tolerance
                );
                
                if (nearbyPivots.length >= 2) {
                    const avgPrice = nearbyPivots.reduce((sum, p) => sum + p.price, 0) / nearbyPivots.length;
                    levels.push({
                        price: avgPrice,
                        strength: nearbyPivots.length,
                        type: type,
                        touches: nearbyPivots.length
                    });
                }
            });
            
            // Remove duplicates and sort by strength
            return levels
                .filter((level, index, self) => 
                    index === self.findIndex(l => Math.abs(l.price - level.price) / level.price < tolerance)
                )
                .sort((a, b) => b.strength - a.strength)
                .slice(0, 5); // Top 5 levels
        }

        function calculateTrendLine(data) {
            const n = data.length;
            const x = Array.from({ length: n }, (_, i) => i);
            const y = data;
            
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }

        function findElliottWaves(closes) {
            // Simplified wave finding - in reality this would be much more complex
            const waves = [];
            const pivots = findPeaks(closes, 5);
            
            for (let i = 0; i < pivots.length - 1; i++) {
                const start = pivots[i];
                const end = pivots[i + 1];
                
                waves.push({
                    start: start.value,
                    end: end.value,
                    direction: end.value > start.value ? 'up' : 'down',
                    length: Math.abs(end.value - start.value),
                    startIndex: start.index,
                    endIndex: end.index
                });
            }
            
            return waves;
        }

        // Make functions globally available
        window.showCustomChart = showCustomChart;
    </script>
</body>
</html>


<!-- SMC PATCH BELOW -->
<script>



</script>
